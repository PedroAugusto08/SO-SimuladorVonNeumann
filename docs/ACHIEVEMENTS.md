# üèÜ Achievements - Progresso do Projeto

> **√öltima atualiza√ß√£o:** 13/11/2025  
> **Prazo Final:** 06/12/2025  
> **Tempo Restante:** 23 dias

---

## üéØ **ESCOPO DO GRUPO (IMPORTANTE!)**

### ‚úÖ **O que ESTE GRUPO est√° implementando:**

| Respons√°vel | Componente | Pontos | Status |
|-------------|------------|--------|--------|
| **Voc√™ (RR)** | Escalonamento Round Robin | 10 | 30% ‚è≥ |
| **Outro membro** | Gerenciamento de Mem√≥ria (FIFO/LRU/Segmenta√ß√£o) | 10 | 0% ‚≠ï |
| **Todos** | Artigo IEEE | 10 | 0% ‚≠ï |
| **TOTAL** | - | **30** | **10%** |

> **‚ö†Ô∏è ATEN√á√ÉO:** Gerenciamento de Mem√≥ria vale **10 pontos completos**, n√£o apenas 6!
> 
> **Breakdown Mem√≥ria (10 pts):**
> - Segmenta√ß√£o Tanenbaum: 2 pts
> - Pol√≠tica FIFO: 3 pts
> - Pol√≠tica LRU: 3 pts
> - M√©tricas de mem√≥ria: 2 pts

---

## üìä Resumo Executivo

| Categoria | Progresso | Itens Completos | Total |
|-----------|-----------|-----------------|-------|
| üèóÔ∏è Arquitetura Multicore | [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë] 75% | 6/8 | 75% |
| ‚öôÔ∏è Escalonamento Round Robin | [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 70% | 7/10 | 70% |
| üß™ **Processos de Teste JSON** | [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0% ‚ö†Ô∏è | 0/3 | 0% |
| üîÑ **Cen√°rios Obrigat√≥rios** | [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0% ‚ö†Ô∏è | 0/3 | 0% |
| üíæ Gerenciamento de Mem√≥ria | [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë] 80% | 4/5 | 80% |
| ÔøΩ **Pol√≠ticas FIFO/LRU** | [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0% ‚ö†Ô∏è | 0/6 | 0% |
| ÔøΩüîí Sincroniza√ß√£o | [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 65% | 3/5 | 65% |
| üìä M√©tricas e Testes | [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 30% | 2/7 | 30% |
| ÔøΩ **Sistema de Logs** | [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0% ‚ö†Ô∏è | 0/4 | 0% |
| üéØ **Baseline Single-Core** | [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0% ‚ö†Ô∏è | 0/5 | 0% |
| ÔøΩüìÑ Artigo IEEE | [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0% | 0/6 | 0% |
| **üéì TOTAL GERAL** | [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 38% | 22/62 | **38%** |

**‚ö†Ô∏è Itens CR√çTICOS adicionados:** 5 etapas obrigat√≥rias identificadas (26 tarefas)!

Nota: barras de progresso substituem imagens externas (progress-bar.dev) por indicadores inline unicode.

---

## üéØ Etapas de Desenvolvimento

### ‚úÖ ETAPA 1: Estrutura B√°sica Multicore (3 dias)
**Status:** ‚úÖ **CONCLU√çDA**  
**Data de Conclus√£o:** 13/11/2025  
**Prazo Recomendado:** 15/11/2025

#### Achievements Completos:

- [x] **Core.hpp criado** ‚úÖ (13/11/2025)
  - Classe `Core` com pipeline MIPS de 5 est√°gios
  - Execu√ß√£o ass√≠ncrona com `std::thread`
  - Cache L1 privada por n√∫cleo
  - Estados: IDLE, BUSY, STOPPING
  - Arquivo: `src/cpu/Core.hpp` (107 linhas)

- [x] **Core.cpp implementado** ‚úÖ (13/11/2025)
  - Construtor e destrutor com gerenciamento de threads
  - M√©todo `execute_async()` para execu√ß√£o paralela
  - M√©todo `wait_completion()` para sincroniza√ß√£o
  - Loop de execu√ß√£o do pipeline
  - Arquivo: `src/cpu/Core.cpp` (161 linhas)

- [x] **M√∫ltiplos n√∫cleos funcionando** ‚úÖ (13/11/2025)
  - 2 n√∫cleos configurados (expans√≠vel)
  - Cada n√∫cleo com thread independente
  - Cache L1 privada isolada
  - Teste: `./simulador` executa com 2 cores

- [x] **Integra√ß√£o com MemoryManager** ‚úÖ (13/11/2025)
  - RAM compartilhada entre n√∫cleos
  - Acesso sincronizado √† mem√≥ria principal
  - Verificado em `src/cpu/Core.cpp`

- [x] **Compila√ß√£o bem-sucedida** ‚úÖ (13/11/2025)
  - Makefile atualizado com `Core.cpp` e `RoundRobinScheduler.cpp`
  - Comando: `make simulador`
  - Sistema: WSL/GCC 13/C++17

- [x] **Conflito de nomes resolvido** ‚úÖ (13/11/2025)
  - Fun√ß√£o `Core()` renomeada para `CoreExecutionLoop()`
  - Ajustado em: `CONTROL_UNIT.hpp/cpp`, `test_cpu_metrics.cpp`

#### Pend√™ncias:

- [ ] ‚è≥ **Teste de carga com 4+ n√∫cleos**
  - Prazo: 16/11/2025
  - Verificar escalabilidade
  - Criar `test_multicore.cpp`

- [ ] ‚è≥ **Documenta√ß√£o de API do Core**
  - Prazo: 17/11/2025
  - Adicionar exemplos de uso
  - Criar `docs/API_CORE.md`

---

### üîÑ ETAPA 2: Escalonador Round Robin (4 dias)
**Status:** üü° **EM ANDAMENTO** (70% completo)  
**In√≠cio:** 13/11/2025  
**Prazo Recomendado:** 19/11/2025

#### Achievements Completos:

- [x] **RoundRobinScheduler.hpp criado** ‚úÖ (13/11/2025)
  - Fila global de prontos (FIFO)
  - Fila de processos bloqueados
  - Vetor de n√∫cleos
  - Estrutura de estat√≠sticas
  - Arquivo: `src/cpu/RoundRobinScheduler.hpp` (68 linhas)

- [x] **RoundRobinScheduler.cpp implementado** ‚úÖ (13/11/2025)
  - M√©todo `add_process()` - adiciona √† fila
  - M√©todo `schedule_cycle()` - ciclo de escalonamento
  - M√©todo `assign_process_to_core()` - atribui√ß√£o
  - M√©todo `collect_finished_processes()` - coleta resultados
  - Arquivo: `src/cpu/RoundRobinScheduler.cpp` (164 linhas)

- [x] **PCB estendido com m√©tricas RR** ‚úÖ (13/11/2025)
  - `arrival_time` - chegada no sistema
  - `start_time` - primeira execu√ß√£o
  - `finish_time` - t√©rmino
  - `total_wait_time` - tempo em espera
  - `context_switches` - trocas de contexto
  - `assigned_core` / `last_core` - rastreamento de n√∫cleo
  - Arquivo: `src/cpu/PCB.hpp`

- [x] **Detec√ß√£o de migra√ß√£o entre n√∫cleos** ‚úÖ (13/11/2025)
  - Implementado em `assign_process_to_core()`
  - Incrementa `context_switches` quando troca de n√∫cleo

- [x] **Fila global de prontos (FIFO)** ‚úÖ (13/11/2025)
  - `std::deque<PCB*> ready_queue`
  - Ordem: primeiro a chegar, primeiro a executar

- [x] **Tratamento de processos bloqueados** ‚úÖ (13/11/2025)
  - `std::deque<PCB*> blocked_queue`
  - M√©todo `handle_blocked_processes()`

- [x] **Quantum configur√°vel** ‚úÖ (13/11/2025)
  - Padr√£o: 100 ciclos
  - Configur√°vel via construtor

#### Pend√™ncias:

- [ ] ‚è≥ **Integra√ß√£o completa com main.cpp**
  - Prazo: 16/11/2025 ‚ö†Ô∏è
  - Atualmente o escalonador existe mas n√£o est√° sendo usado no loop principal
  - Substituir l√≥gica atual por `RoundRobinScheduler`
  - **CR√çTICO:** Necess√°rio para testes de m√∫ltiplos processos

- [ ] ‚è≥ **Implementar preemp√ß√£o real por quantum**
  - Prazo: 17/11/2025
  - Interromper execu√ß√£o quando quantum expira
  - Atualmente depende de processo terminar ou bloquear

- [ ] ‚è≥ **M√©tricas agregadas funcionando**
  - Prazo: 18/11/2025
  - `get_statistics()` retorna valores calculados
  - Tempo m√©dio de espera/turnaround
  - Taxa de throughput

---

### ÔøΩ ETAPA 2.5: Cen√°rios de Execu√ß√£o (3 dias) ‚ö†Ô∏è‚ö†Ô∏è
**Status:** ‚≠ï **N√ÉO INICIADA** (0%) - **CR√çTICO!**  
**Prazo Recomendado:** 17/11/2025  
**Pontos em Jogo:** 4 pontos (2 + 2)

> **‚ö†Ô∏è OBRIGAT√ìRIO:** Especifica√ß√£o exige 2 cen√°rios distintos!

#### Pend√™ncias CR√çTICAS:

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Cen√°rio 1: Round Robin N√£o-Preemptivo** (2 pts)
  - Prazo: 17/11/2025 ‚ö†Ô∏è
  - Especifica√ß√£o: "Cen√°rio n√£o preemptivo: todas as tarefas s√£o executadas at√© a conclus√£o, sem interrup√ß√µes"
  - **O que fazer:**
    - Adicionar flag `--non-preemptive` ao simulador
    - Round Robin SEM quantum (processos at√© terminar)
    - Ordem FIFO mantida, mas sem interrup√ß√£o
  - **Arquivos:** `src/main.cpp`, `RoundRobinScheduler.cpp`
  - **Teste:** Rodar 5 processos e verificar que n√£o h√° preemp√ß√£o

- [ ] ‚è≥ **Cen√°rio 2: Round Robin Preemptivo** (2 pts)
  - Prazo: 19/11/2025
  - Especifica√ß√£o: "Cen√°rio preemptivo: todas as tarefas s√£o pass√≠veis de interrup√ß√£o"
  - **O que fazer:**
    - Garantir quantum funciona (j√° implementado parcialmente)
    - Context switch preserva estado completo
    - Processo interrompido volta ao fim da fila
  - **Arquivos:** `src/cpu/Core.cpp`, `RoundRobinScheduler.cpp`
  - **Teste:** Verificar que processos s√£o interrompidos no quantum

- [ ] ‚ö†Ô∏è **Compara√ß√£o entre cen√°rios**
  - Prazo: 20/11/2025
  - Executar mesmos processos em ambos cen√°rios
  - Coletar m√©tricas de cada um
  - Incluir compara√ß√£o no artigo

---

### üß™ ETAPA 2.6: Processos de Teste e Carga Inicial (2 dias) ‚ö†Ô∏è‚ö†Ô∏è
**Status:** ‚≠ï **N√ÉO INICIADA** (0%) - **BLOQUEADOR!**  
**Prazo Recomendado:** 15/11/2025  
**Import√¢ncia:** CR√çTICA (sem isso, nada funciona!)

> **‚ö†Ô∏è BLOQUEADOR:** Sem processos JSON, n√£o h√° como testar Round Robin!

#### Pend√™ncias CR√çTICAS:

- [ ] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è **Criar 5+ processos JSON variados**
  - Prazo: 15/11/2025 (2 DIAS!) ‚ö†Ô∏è
  - **BLOQUEIO:** Sem isso, imposs√≠vel testar escalonamento!
  - **O que criar:**
    - `processo1.json` - CPU-bound (muitas opera√ß√µes ALU, poucas mem√≥rias)
    - `processo2.json` - I/O-bound (muitos acessos √† mem√≥ria)
    - `processo3.json` - Balanceado (mix de CPU e mem√≥ria)
    - `processo4.json` - Curto (100-200 instru√ß√µes)
    - `processo5.json` - Longo (1000+ instru√ß√µes)
  - **Pasta:** `src/tasks/`
  - **Formato:** Copiar estrutura de `tasks.json` existente

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Implementar carga inicial completa**
  - Prazo: 16/11/2025 ‚ö†Ô∏è
  - Especifica√ß√£o: "todos os programas pertencentes ao lote devem ser completamente carregados na mem√≥ria principal ANTES do in√≠cio da execu√ß√£o"
  - **O que fazer:**
    ```cpp
    // Em main.cpp
    vector<string> process_files = {
        "processo1.json", "processo2.json", 
        "processo3.json", "processo4.json", "processo5.json"
    };
    
    // PASSO 1: Carregar TODOS antes
    for (auto& file : process_files) {
        PCB* pcb = load_process_from_json(file);
        scheduler.add_process(pcb);
    }
    
    // PASSO 2: S√ì DEPOIS executar
    scheduler.run_until_completion();
    ```
  - **Arquivos:** `src/main.cpp`
  - **Teste:** Verificar que todos 5 processos s√£o carregados antes da execu√ß√£o

- [ ] ‚è≥ **Documentar formato JSON**
  - Prazo: 17/11/2025
  - Criar `docs/FORMATO_JSON.md`
  - Explicar estrutura de processos
  - Exemplos de cada tipo

---

### ÔøΩüíæ ETAPA 3: Gerenciamento de Mem√≥ria (4 dias)
**Status:** ‚úÖ **QUASE COMPLETA** (80%)  
**Prazo Recomendado:** 23/11/2025

#### Achievements Completos:

- [x] **MemoryManager compartilhado** ‚úÖ (Antes de 13/11)
  - RAM √∫nica para todos os n√∫cleos
  - Arquivo: `src/memory/MemoryManager.hpp/cpp`

- [x] **Cache L1 privada por n√∫cleo** ‚úÖ (13/11/2025)
  - Cada n√∫cleo tem `std::unique_ptr<Cache> L1_cache`
  - Implementado em `Core::Core()`
  - Arquivo: `src/cpu/Core.cpp` linha 18

- [x] **Contabiliza√ß√£o de cache hits/misses** ‚úÖ (13/11/2025)
  - `PCB::cache_hits` e `PCB::cache_misses`
  - Incrementados durante acesso √† mem√≥ria
  - Arquivo: `src/cpu/PCB.hpp`

- [x] **Sincroniza√ß√£o de acesso √† RAM** ‚úÖ (Antes de 13/11)
  - `std::mutex` em `MemoryManager`
  - Acesso thread-safe

#### Pend√™ncias:

- [ ] ‚è≥ **Teste de conten√ß√£o de mem√≥ria**
  - Prazo: 20/11/2025
  - M√∫ltiplos n√∫cleos acessando RAM simultaneamente
  - Medir impacto de locks

---


### üíæ ETAPA 3.4: Segmenta√ß√£o Tanenbaum e M√©tricas de Mem√≥ria (3 dias) ‚ö†Ô∏è
**Status:** ‚≠ï **N√ÉO INICIADA** (0%) - **CR√çTICO!**  
**Prazo Recomendado:** 20/11/2025  
**Pontos em Jogo:** 4 pontos (2 + 2)  
**Respons√°vel:** OUTRO MEMBRO DO GRUPO üî¥

> **‚ö†Ô∏è OBRIGAT√ìRIO:** Especifica√ß√£o exige:
> - "mapeamento de endere√ßos segundo um modelo inspirado em Tanenbaum"
> - "A utiliza√ß√£o de mem√≥ria ao longo do tempo"

#### Contexto e Objetivo:

**O que √© segmenta√ß√£o de mem√≥ria (modelo Tanenbaum)?**
- Mem√≥ria acessada por palavras de X bits
- **Parte dos bits** = endere√ßo do bloco/segmento
- **Parte dos bits** = deslocamento interno (offset)
- Exemplo: palavra de 16 bits = 8 bits (bloco) + 8 bits (offset)

**Por que √© importante?**
- Permite endere√ßamento virtual
- Facilita gerenciamento de cache  
- Base para pol√≠ticas de substitui√ß√£o FIFO/LRU

#### Pend√™ncias CR√çTICAS:

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Implementar segmenta√ß√£o de endere√ßos Tanenbaum** (2 pts)
  - Prazo: 18/11/2025 ‚ö†Ô∏è
  - Especifica√ß√£o: "parte dos bits representa o endere√ßo do bloco e parte o deslocamento interno"
  - **O que fazer:**
    ```cpp
    class MemoryAddressing {
        static constexpr int WORD_BITS = 16;
        static constexpr int BLOCK_BITS = 8;    // 256 blocos
        static constexpr int OFFSET_BITS = 8;   // 256 bytes/bloco
    public:
        struct Address {
            uint16_t block;
            uint16_t offset;
        };
        
        static Address to_segmented(uint32_t linear) {
            Address addr;
            addr.block = (linear >> OFFSET_BITS) & ((1 << BLOCK_BITS) - 1);
            addr.offset = linear & ((1 << OFFSET_BITS) - 1);
            return addr;
        }
        
        static uint32_t to_linear(Address addr) {
            return (addr.block << OFFSET_BITS) | addr.offset;
        }
    };
    ```
  - **Arquivos:** Criar `src/memory/MemoryAddressing.hpp`, `.cpp`
  - **Integra√ß√£o:** Modificar `MemoryManager::access()` para usar segmenta√ß√£o
  - **Teste:** Endere√ßo 300 = Bloco 1 + Offset 44

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Coletar m√©tricas de utiliza√ß√£o de mem√≥ria** (2 pts)
  - Prazo: 20/11/2025 ‚ö†Ô∏è
  - Especifica√ß√£o: "A utiliza√ß√£o de mem√≥ria ao longo do tempo"
  - **O que fazer:**
    ```cpp
    class MemoryMetrics {
        struct Snapshot {
            uint64_t timestamp;
            size_t bytes_used;
            double utilization_percent;
            int num_processes;
        };
        std::vector<Snapshot> history;
    public:
        void take_snapshot(uint64_t cycle, size_t used, int procs);
        void save_to_csv(const std::string& filename);
    };
    ```
  - **Sa√≠da:** `logs/memory_utilization.csv`
  - **Gr√°fico:** Para se√ß√£o "Resultados" do artigo
  - **Arquivos:** Criar `src/memory/MemoryMetrics.hpp`, `.cpp`

- [ ] ‚è≥ **Integrar snapshots no loop principal**
  - Prazo: 20/11/2025
  - No `main.cpp`: chamar `mem_metrics.take_snapshot()` a cada 1000 ciclos
  - Salvar CSV no final da execu√ß√£o

- [ ] ‚è≥ **Criar gr√°fico Python**
  - Prazo: 21/11/2025
  - Script `scripts/plot_memory_utilization.py`
  - Usar no artigo (se√ß√£o Resultados)

#### Divis√£o de Tarefas:
- Dia 1 (18/11): Implementar `MemoryAddressing` + testes
- Dia 2 (19/11): Implementar `MemoryMetrics` + integra√ß√£o
- Dia 3 (20/11): Gerar CSV, gr√°fico, validar

---

### ÔøΩ ETAPA 3.5: Pol√≠ticas de Substitui√ß√£o FIFO e LRU (5 dias) ‚ö†Ô∏è
**Status:** ‚≠ï **N√ÉO INICIADA** (0%) - **CR√çTICO!**  
**Prazo Recomendado:** 23/11/2025  
**Pontos em Jogo:** 6 pontos (3 + 3)  
**Respons√°vel:** OUTRO MEMBRO DO GRUPO üî¥

> **‚ö†Ô∏è OBRIGAT√ìRIO:** Especifica√ß√£o exige "pol√≠ticas de substitui√ß√£o (ex.: FIFO, LRU)"!  
> **üìå ATEN√á√ÉO:** Esta etapa √© de OUTRO membro, mas todos devem conhecer!

#### Contexto e Objetivo:

**O que s√£o pol√≠ticas de substitui√ß√£o?**
- Quando a cache est√° CHEIA e precisa buscar novo dado
- Precisa REMOVER algum bloco antigo (substitui√ß√£o)
- FIFO = remove o mais antigo (First In, First Out)
- LRU = remove o menos recentemente usado (Least Recently Used)

**Onde implementar?**
- Arquivos: `src/memory/CachePolicy.hpp/cpp` OU `src/memory/cache.cpp`
- Integra√ß√£o: `Cache::access()` chama pol√≠tica quando cache full

#### Pend√™ncias CR√çTICAS:

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Implementar pol√≠tica FIFO** (3 pts)
  - Prazo: 21/11/2025 ‚ö†Ô∏è
  - Especifica√ß√£o: "pol√≠tica de substitui√ß√£o FIFO"
  - **O que fazer:**
    ```cpp
    // Criar classe FIFOPolicy
    class FIFOPolicy : public ReplacementPolicy {
        std::queue<int> insertion_order; // Ordem de inser√ß√£o
    public:
        int select_victim() override {
            int victim = insertion_order.front();
            insertion_order.pop();
            return victim; // Remove o mais antigo
        }
        
        void on_access(int block_id) override {
            insertion_order.push(block_id);
        }
    };
    ```
  - **Arquivos:** Criar `src/memory/FIFOPolicy.hpp`, `FIFOPolicy.cpp`
  - **Teste:** Cache com 4 blocos, inserir 5¬∫ e verificar que 1¬∫ foi removido

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Implementar pol√≠tica LRU** (3 pts)
  - Prazo: 23/11/2025 ‚ö†Ô∏è
  - Especifica√ß√£o: "pol√≠tica de substitui√ß√£o LRU"
  - **O que fazer:**
    ```cpp
    // Criar classe LRUPolicy
    class LRUPolicy : public ReplacementPolicy {
        std::map<int, uint64_t> last_access_time; // Timestamp de acesso
        uint64_t current_time = 0;
    public:
        int select_victim() override {
            // Encontra bloco com menor timestamp
            int victim = -1;
            uint64_t oldest_time = UINT64_MAX;
            for (auto& [block, time] : last_access_time) {
                if (time < oldest_time) {
                    oldest_time = time;
                    victim = block;
                }
            }
            return victim; // Remove menos usado
        }
        
        void on_access(int block_id) override {
            last_access_time[block_id] = current_time++;
        }
    };
    ```
  - **Arquivos:** Criar `src/memory/LRUPolicy.hpp`, `LRUPolicy.cpp`
  - **Teste:** Acessar blocos [1,2,3,4,1], cache cheio, inserir 5 ‚Üí remove bloco 2

- [ ] ‚ö†Ô∏è **Integrar pol√≠ticas ao Cache**
  - Prazo: 23/11/2025 ‚ö†Ô∏è
  - Modificar `Cache` para aceitar pol√≠tica:
    ```cpp
    // Em cache.hpp
    class Cache {
        std::unique_ptr<ReplacementPolicy> policy;
    public:
        Cache(CachePolicyType type) {
            if (type == CachePolicyType::FIFO)
                policy = std::make_unique<FIFOPolicy>();
            else if (type == CachePolicyType::LRU)
                policy = std::make_unique<LRUPolicy>();
        }
        
        void access(int address) {
            if (is_full() && !is_hit(address)) {
                int victim = policy->select_victim();
                evict(victim);
            }
            // ... resto do c√≥digo
            policy->on_access(address);
        }
    };
    ```
  - **Arquivos:** `src/memory/cache.hpp`, `cache.cpp`

- [ ] ‚è≥ **Adicionar flag de escolha de pol√≠tica**
  - Prazo: 24/11/2025
  - Permitir rodar simulador com diferentes pol√≠ticas:
    ```bash
    ./simulador --cache-policy=FIFO
    ./simulador --cache-policy=LRU
    ```
  - Modificar `main.cpp` para aceitar argumento
  - **Arquivos:** `src/main.cpp`

- [ ] ‚è≥ **Testar compara√ß√£o FIFO vs LRU**
  - Prazo: 25/11/2025
  - Rodar mesmos 5 processos com FIFO
  - Rodar mesmos 5 processos com LRU
  - Comparar:
    - Cache hit rate (%)
    - Tempo total de execu√ß√£o
    - N√∫mero de misses
  - Salvar resultados:
    - `logs/metrics_FIFO.csv`
    - `logs/metrics_LRU.csv`

- [ ] ‚è≥ **Documentar pol√≠ticas**
  - Prazo: 26/11/2025
  - Criar `docs/POLITICAS_CACHE.md`
  - Explicar FIFO vs LRU
  - Mostrar exemplos de uso
  - Incluir gr√°ficos comparativos no artigo

#### Recursos para Implementa√ß√£o:

**Refer√™ncias Te√≥ricas:**
- Tanenbaum, "Modern Operating Systems", Cap√≠tulo 3.4 (Page Replacement)
- Silberschatz, "Operating Systems Concepts", Cap√≠tulo 10 (Virtual Memory)

**Exemplos de C√≥digo:**
- Ver `src/memory/cachePolicy.cpp` (j√° existe estrutura b√°sica)
- Ver `src/memory/cache.cpp` (classe Cache atual)

**Testes Sugeridos:**
```cpp
// Teste FIFO
Cache cache_fifo(4, CachePolicyType::FIFO); // 4 blocos
cache_fifo.access(1); // Miss
cache_fifo.access(2); // Miss
cache_fifo.access(3); // Miss
cache_fifo.access(4); // Miss
cache_fifo.access(5); // Miss ‚Üí remove bloco 1 (mais antigo)
assert(!cache_fifo.contains(1)); // Bloco 1 foi removido

// Teste LRU
Cache cache_lru(4, CachePolicyType::LRU);
cache_lru.access(1); // Miss
cache_lru.access(2); // Miss
cache_lru.access(3); // Miss
cache_lru.access(4); // Miss
cache_lru.access(1); // Hit (atualiza timestamp)
cache_lru.access(5); // Miss ‚Üí remove bloco 2 (menos usado)
assert(!cache_lru.contains(2)); // Bloco 2 foi removido
assert(cache_lru.contains(1));  // Bloco 1 ainda est√° (foi usado recentemente)
```

#### Divis√£o de Tarefas (Sugerida para respons√°vel):

**Dia 1-2 (19-20 Nov):**
- [ ] Estudar pol√≠ticas FIFO e LRU (teoria)
- [ ] Analisar c√≥digo existente em `cachePolicy.cpp`
- [ ] Criar classes FIFOPolicy e LRUPolicy

**Dia 3 (21 Nov):**
- [ ] Implementar e testar FIFO
- [ ] Criar testes unit√°rios

**Dia 4 (22 Nov):**
- [ ] Implementar e testar LRU
- [ ] Criar testes unit√°rios

**Dia 5 (23 Nov):**
- [ ] Integrar ao Cache principal
- [ ] Testar com processos completos
- [ ] Comparar resultados FIFO vs LRU

---

### ÔøΩüîí ETAPA 4: Sincroniza√ß√£o e Concorr√™ncia (3 dias)
**Status:** üü° **PARCIAL** (65%)  
**Prazo Recomendado:** 26/11/2025

#### Achievements Completos:

- [x] **Mutexes na fila de prontos** ‚úÖ (13/11/2025)
  - `std::mutex scheduler_mutex` em RoundRobinScheduler
  - `std::lock_guard` em m√©todos cr√≠ticos

- [x] **Sincroniza√ß√£o de threads Core** ‚úÖ (13/11/2025)
  - `std::thread execution_thread`
  - `wait_completion()` com `join()`

- [x] **Atomic operations no PCB** ‚úÖ (13/11/2025)
  - Todos os contadores s√£o `std::atomic<uint64_t>`
  - Thread-safe sem locks

#### Pend√™ncias:

- [ ] ‚è≥ **Teste de race conditions**
  - Prazo: 22/11/2025
  - Usar ThreadSanitizer (`-fsanitize=thread`)
  - Verificar deadlocks

- [ ] ‚è≥ **Documentar estrat√©gia de locks**
  - Prazo: 24/11/2025
  - Criar `docs/SINCRONIZACAO.md`
  - Explicar ordem de aquisi√ß√£o de mutexes

---

### üìä ETAPA 5: M√©tricas e Valida√ß√£o (5 dias)
**Status:** ‚≠ï **N√ÉO INICIADA** (30%)  
**Prazo Recomendado:** 01/12/2025 ‚ö†Ô∏è

#### Achievements Completos:

- [x] **Estrutura de m√©tricas no PCB** ‚úÖ (13/11/2025)
  - Campos: `arrival_time`, `start_time`, `finish_time`, etc.
  - M√©todos: `get_turnaround_time()`, `get_wait_time()`

- [x] **Estrutura Statistics no Scheduler** ‚úÖ (13/11/2025)
  - `avg_wait_time`, `avg_turnaround_time`, etc.
  - M√©todo `get_statistics()`

#### Pend√™ncias (CR√çTICAS):

- [ ] ‚è≥ **Implementar coleta de m√©tricas em arquivo**
  - Prazo: 20/11/2025
  - Salvar em `logs/metrics.csv` ou `.json`
  - Colunas: PID, tempo_espera, turnaround, n√∫cleo, etc.

- [ ] ‚è≥ **Calcular Speedup**
  - Prazo: 24/11/2025
  - F√≥rmula: $Speedup = \frac{T_{single}}{T_{multi}}$
  - Gerar gr√°fico de speedup vs. n√∫mero de n√∫cleos

- [ ] ‚è≥ **Criar gr√°ficos de utiliza√ß√£o de CPU**
  - Prazo: 26/11/2025
  - Usar Python/matplotlib ou gnuplot
  - Gr√°fico: tempo x utiliza√ß√£o por n√∫cleo

---

### üìù ETAPA 5.5: Sistema de Logs e Rastreamento (2 dias) ‚ö†Ô∏è
**Status:** ‚≠ï **N√ÉO INICIADA** (0%) - **CR√çTICO!**  
**Prazo Recomendado:** 20/11/2025  
**Pontos em Jogo:** 1 ponto

> **‚ö†Ô∏è OBRIGAT√ìRIO:** Especifica√ß√£o exige "LOG DETALHADO das execu√ß√µes"!

#### Pend√™ncias CR√çTICAS:

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Implementar arquivo de log principal** (1 pt)
  - Prazo: 18/11/2025 ‚ö†Ô∏è
  - Especifica√ß√£o: "LOG DETALHADO registrando o que ocorreu em cada instante"
  - **O que fazer:**
    ```cpp
    // Criar classe Logger
    class ExecutionLogger {
        std::ofstream log_file;
        std::mutex log_mutex;
    public:
        void log_event(int core_id, int pid, string event, uint64_t timestamp);
    };
    
    // Eventos a registrar:
    // - Processo carregado na mem√≥ria
    // - Processo iniciou execu√ß√£o (core X)
    // - Context switch (de PID X para Y)
    // - Processo terminou
    // - Acesso √† mem√≥ria (cache hit/miss)
    ```
  - **Arquivos:** Criar `src/logger/ExecutionLogger.hpp`, `ExecutionLogger.cpp`
  - **Sa√≠da:** `logs/execution_YYYYMMDD_HHMMSS.log`

- [ ] ‚ö†Ô∏è **Integrar log em todos pontos cr√≠ticos**
  - Prazo: 19/11/2025 ‚ö†Ô∏è
  - Core::execute_process() ‚Üí log in√≠cio/fim
  - RoundRobinScheduler::schedule() ‚Üí log aloca√ß√£o
  - RoundRobinScheduler::context_switch() ‚Üí log troca
  - MemoryManager::access() ‚Üí log cache hit/miss
  - **Arquivos:** `Core.cpp`, `RoundRobinScheduler.cpp`, `MemoryManager.cpp`

- [ ] ‚è≥ **Criar arquivo de m√©tricas CSV**
  - Prazo: 20/11/2025
  - Formato: `PID,arrival,start,finish,wait,turnaround,core_id`
  - **Sa√≠da:** `logs/metrics.csv`
  - Facilita importa√ß√£o em Python/Excel para gr√°ficos

- [ ] ‚è≥ **Documentar formato dos logs**
  - Prazo: 21/11/2025
  - Criar `docs/FORMATO_LOGS.md`
  - Exemplo de cada tipo de evento

---

### üéØ ETAPA 5.6: Baseline e Compara√ß√£o Single-Core (3 dias) ‚ö†Ô∏è‚ö†Ô∏è
**Status:** ‚≠ï **N√ÉO INICIADA** (0%) - **CR√çTICO!**  
**Prazo Recomendado:** 26/11/2025  
**Pontos em Jogo:** 2 pontos

> **‚ö†Ô∏è OBRIGAT√ìRIO:** Especifica√ß√£o exige "Compara√ß√£o com baseline single-core"!

#### Pend√™ncias CR√çTICAS:

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Implementar modo single-core** (2 pts)
  - Prazo: 24/11/2025 ‚ö†Ô∏è
  - Especifica√ß√£o: "compara√ß√£o com baseline (execu√ß√£o single-core)"
  - **O que fazer:**
    ```cpp
    // Adicionar flag ao simulador
    // main.cpp:
    bool single_core_mode = false;
    if (argc > 1 && strcmp(argv[1], "--single-core") == 0) {
        single_core_mode = true;
    }
    
    // Criar apenas 1 core ao inv√©s de N
    int num_cores = single_core_mode ? 1 : 2;
    ```
  - **Arquivos:** `src/main.cpp`
  - **Teste:** Rodar com `./simulador --single-core`

- [ ] ‚ö†Ô∏è **Executar bateria de testes comparativa**
  - Prazo: 25/11/2025 ‚ö†Ô∏è
  - Rodar mesmos 5 processos em:
    - 1 core (baseline)
    - 2 cores (atual)
    - 4 cores (se implementado)
  - Salvar resultados separados:
    - `logs/metrics_1core.csv`
    - `logs/metrics_2cores.csv`
    - `logs/metrics_4cores.csv`

- [ ] ‚ö†Ô∏è **Calcular Speedup e Efficiency**
  - Prazo: 26/11/2025 ‚ö†Ô∏è
  - F√≥rmulas:
    - $Speedup = \frac{T_{1core}}{T_{Ncores}}$
    - $Efficiency = \frac{Speedup}{N} \times 100\%$
  - Criar tabela comparativa para o artigo
  - **Script:** Criar `scripts/calculate_speedup.py`

- [ ] ‚è≥ **Gerar gr√°ficos comparativos**
  - Prazo: 26/11/2025
  - Gr√°fico 1: Tempo total (1 vs 2 vs 4 cores)
  - Gr√°fico 2: Speedup por n√∫mero de cores
  - Gr√°fico 3: Utiliza√ß√£o de CPU por core
  - **Script:** `scripts/plot_comparison.py`

- [ ] ‚è≥ **Documentar resultados**
  - Prazo: 27/11/2025
  - Criar `docs/RESULTADOS_BASELINE.md`
  - Incluir tabelas e gr√°ficos
  - An√°lise: Round Robin escala bem? Por qu√™?

---

### üìÑ ETAPA 6: Artigo IEEE (5 dias)
**Status:** ‚≠ï **N√ÉO INICIADA** (0%)  
**Prazo Recomendado:** 06/12/2025 (DATA LIMITE) ‚ö†Ô∏è‚ö†Ô∏è

#### Template e Estrutura:

- [ ] ‚è≥ **Baixar template IEEE LaTeX**
  - Prazo: 27/11/2025
  - Usar modelo de confer√™ncia IEEE
  - Link: https://www.ieee.org/conferences/publishing/templates.html

- [ ] ‚è≥ **Escrever Abstract**
  - Prazo: 28/11/2025
  - 150-200 palavras
  - Resumir: problema, solu√ß√£o, resultados

- [ ] ‚è≥ **Escrever Introdu√ß√£o**
  - Prazo: 29/11/2025
  - Contexto: Arquitetura Von Neumann
  - Problema: Bottleneck, necessidade de multicore
  - Solu√ß√£o: Simulador com Round Robin

- [ ] ‚è≥ **Escrever Metodologia**
  - Prazo: 01/12/2025
  - Descrever arquitetura do simulador
  - Algoritmo Round Robin
  - Estrutura de dados

- [ ] ‚è≥ **Escrever Resultados e Discuss√£o**
  - Prazo: 03/12/2025
  - Apresentar m√©tricas coletadas
  - Gr√°ficos de speedup, utiliza√ß√£o, tempo de espera
  - Comparar com baseline

- [ ] ‚è≥ **Escrever Conclus√£o e Refer√™ncias**
  - Prazo: 04/12/2025
  - Resumir contribui√ß√µes
  - Trabalhos futuros
  - M√≠nimo 10 refer√™ncias bibliogr√°ficas

---

## üìÖ Cronograma Visual (ATUALIZADO)

```
Novembro 2025          |  Dezembro 2025
-----------------------+----------------
13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 01 02 03 04 05 06
‚úÖ ‚è≥ ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è üü° ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è üìÑ üìÑ üìÑ üìÑ üìÑ üìÑ üìÑ üìÑ üìÑ üèÅ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ        ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ        ‚îî‚îÄ ENTREGA FINAL
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Revis√£o Artigo
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ     ‚îÇ     ‚îÇ     ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Resultados Artigo
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ     ‚îÇ     ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Gr√°ficos
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ     ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Baseline 1-core ‚ö†Ô∏è
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FIFO/LRU (outro membro) üü°
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Testes Sincroniza√ß√£o
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Logs Integrados ‚ö†Ô∏è
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Compara√ß√£o Cen√°rios
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Cen√°rio Preemptivo ‚è≥
‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Cen√°rio N√£o-Preemptivo ‚ö†Ô∏è‚ö†Ô∏è
‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Carga Inicial Completa
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 5+ JSONs Processos ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Integra√ß√£o Core+RR
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Hoje ‚úÖ (13 Nov)

üìä NOVA ESTRUTURA DE ETAPAS:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ETAPA 1: ‚úÖ Multicore (75%) - 13/11                          ‚îÇ
‚îÇ ETAPA 2: üü° Round Robin (70%) - 14/11                        ‚îÇ
‚îÇ ETAPA 2.5: ‚ö†Ô∏è Cen√°rios Obrigat√≥rios (0%) - 17-19/11 [4 pts] ‚îÇ
‚îÇ ETAPA 2.6: ‚ö†Ô∏è‚ö†Ô∏è Processos JSON (0%) - 15-16/11 [BLOQUEIO]   ‚îÇ
‚îÇ ETAPA 3: üü° Mem√≥ria (80%) - 16-20/11                         ‚îÇ
‚îÇ ETAPA 3.4: üî¥ Segmenta√ß√£o+M√©tricas (0%) - 18-20/11 [4 pts]  ‚îÇ
‚îÇ ETAPA 3.5: üî¥ FIFO/LRU (0%) - 19-23/11 [6 pts] (outro mbr)  ‚îÇ
‚îÇ ETAPA 4: üü° Sincroniza√ß√£o (65%) - 21-24/11                   ‚îÇ
‚îÇ ETAPA 5: ‚è≥ M√©tricas (30%) - 22-26/11                        ‚îÇ
‚îÇ ETAPA 5.5: ‚ö†Ô∏è Logs (0%) - 18-20/11 [1 pt]                   ‚îÇ
‚îÇ ETAPA 5.6: ‚ö†Ô∏è‚ö†Ô∏è Baseline (0%) - 24-26/11 [2 pts]            ‚îÇ
‚îÇ ETAPA 6: ‚≠ï Artigo IEEE (0%) - 27/11-06/12 [10 pts]          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è DEADLINES CR√çTICOS (pr√≥ximos 7 dias):
‚Ä¢ 15 Nov (SEX): 5+ processos JSON criados [BLOQUEADOR!]
‚Ä¢ 16 Nov (S√ÅB): Carga inicial batch implementada
‚Ä¢ 17 Nov (DOM): Cen√°rio n√£o-preemptivo funcionando [2 pts]
‚Ä¢ 18-20 Nov: Segmenta√ß√£o Tanenbaum + M√©tricas mem√≥ria [4 pts]
‚Ä¢ 19-23 Nov: FIFO/LRU (outro membro) [6 pts]
```

---

## ‚ö†Ô∏è **ITENS CR√çTICOS FALTANDO (PODEM PERDER PONTOS)**

> **üìå REFER√äNCIA:** Veja detalhes completos de implementa√ß√£o nas **ETAPAS 2.5, 2.6, 5.5 e 5.6** acima!

### üî¥ **URGENTE - Esta Semana (14-17 Nov):**

#### 1. **5+ Processos JSON** [BLOQUEADOR!!!] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
   - **Especifica√ß√£o:** Criar "carga inicial com processos para testar"
   - **üìÇ VER:** ETAPA 2.6 (linha ~160)
   - **O que fazer:**
     - Criar `processo1.json` (CPU-bound)
     - Criar `processo2.json` (I/O-bound)  
     - Criar `processo3.json` (balanceado)
     - Criar `processo4.json` (curto, 100-200 inst)
     - Criar `processo5.json` (longo, 1000+ inst)
   - **Prazo:** 15/11/2025 (AMANH√É!)
   - **Risco:** Sem isso, NADA pode ser testado!

#### 2. **Cen√°rio N√£o-Preemptivo** (-2 pts se n√£o fizer) ‚ö†Ô∏è‚ö†Ô∏è
   - **Especifica√ß√£o:** "Cen√°rio n√£o preemptivo: todas as tarefas s√£o executadas at√© a conclus√£o, sem interrup√ß√µes"
   - **üìÇ VER:** ETAPA 2.5 (linha ~80)
   - **O que fazer:**
     - Criar flag `--non-preemptive` ou similar
     - Round Robin SEM quantum
     - Processos executam at√© terminar
   - **Prazo:** 17/11/2025
   - **Arquivo:** `src/main.cpp` + `RoundRobinScheduler`

#### 2. **Criar 5+ Processos JSON** (bloqueador para testes) ‚ö†Ô∏è‚ö†Ô∏è
   - **Especifica√ß√£o:** "Ler do disco um lote inicial de programas previamente definido"
   - **O que fazer:**
     - `processo1.json` - CPU-bound
     - `processo2.json` - I/O-bound
     - Criar `processo5.json` (longo, 1000+ inst)
   - **Prazo:** 15/11/2025 (AMANH√É!)
   - **Risco:** Sem isso, NADA pode ser testado!
   - **üìÇ VER:** ETAPA 2.6 (detalhes completos)

#### 2. **Cen√°rio N√£o-Preemptivo** (-2 pts se n√£o fizer) ‚ö†Ô∏è‚ö†Ô∏è
   - **Especifica√ß√£o:** "Cen√°rio n√£o preemptivo: todas as tarefas s√£o executadas at√© a conclus√£o, sem interrup√ß√µes"
   - **üìÇ VER:** ETAPA 2.5 (linha ~80)
   - **O que fazer:**
     - Adicionar flag `--non-preemptive` ao simulador
     - Round Robin SEM quantum (processos at√© terminar)
     - Ordem FIFO mantida, mas sem interrup√ß√£o
   - **Prazo:** 17/11/2025
   - **üìÇ VER:** ETAPA 2.5 (detalhes completos)

#### 3. **Carga Inicial Completa** (requisito obrigat√≥rio) ‚ö†Ô∏è
   - **Especifica√ß√£o:** "todos os programas pertencentes ao lote devem ser completamente carregados na mem√≥ria principal ANTES do in√≠cio da execu√ß√£o"
   - **üìÇ VER:** ETAPA 2.6 (linha ~160)
   - **O que fazer:**
     ```cpp
     // Carregar TODOS antes
     for (auto& file : process_files) {
         scheduler.add_process(load(file));
     }
     // S√ì DEPOIS executar
     scheduler.run();
     ```
   - **Prazo:** 16/11/2025
   - **Arquivo:** `src/main.cpp`

### üü° **IMPORTANTE - Semana 18-26 Nov:**

#### 4. **Arquivos de Log** (-1 pt se n√£o fizer) ‚ö†Ô∏è
   - **Especifica√ß√£o:** "todas as execu√ß√µes devem gerar arquivos de log contendo m√©tricas"
   - **üìÇ VER:** ETAPA 5.5 (linha ~370)
   - **O que fazer:**
     - Criar classe `ExecutionLogger`
     - Log de cada evento (in√≠cio, fim, context switch, cache hit/miss)
     - Salvar em `logs/execution_{timestamp}.log`
     - Gerar tamb√©m `metrics.csv` para an√°lise
   - **Prazo:** 20/11/2025
   - **üìÇ VER:** ETAPA 5.5 (detalhes completos)

#### 5. **Baseline Single-Core** (-2 pts se n√£o fizer) ‚ö†Ô∏è‚ö†Ô∏è
   - **Especifica√ß√£o:** "deve-se utilizar como baseline a arquitetura single-core previamente desenvolvida"
   - **üìÇ VER:** ETAPA 5.6 (linha ~415)
   - **O que fazer:**
     - Adicionar flag `--single-core`
     - Rodar mesmos 5 processos em 1 core
     - Comparar com 2 e 4 n√∫cleos
     - Calcular Speedup e Efficiency
   - **Prazo:** 24-26/11/2025
   - **Necess√°rio para artigo!**
   - **üìÇ VER:** ETAPA 5.6 (detalhes completos)

#### 6. **Pol√≠ticas FIFO e LRU** (-6 pts se n√£o fizer) üî¥üî¥
   - **Especifica√ß√£o:** "pol√≠ticas de substitui√ß√£o de cache (ex.: FIFO, LRU)"
   - **üìÇ VER:** ETAPA 3.5 (linha ~290)
   - **Respons√°vel:** OUTRO MEMBRO DO GRUPO!
   - **O que fazer:**
     - Implementar `FIFOPolicy` (remove bloco mais antigo)
     - Implementar `LRUPolicy` (remove bloco menos usado)
     - Integrar ao `Cache::access()`
     - Testar compara√ß√£o FIFO vs LRU
   - **Prazo:** 21-23/11/2025
   - **‚ö†Ô∏è ATEN√á√ÉO:** Sem isso, perde 6 pontos (20% da nota)!
   - **üìÇ VER:** ETAPA 3.5 (guia completo com c√≥digo, testes e divis√£o de tarefas)

---

## üéØ Pr√≥ximos 5 Dias Cr√≠ticos

### üìå Hoje - 13/11/2025 (Quarta)
- [x] ‚úÖ Compilar e validar `Core` + `RoundRobinScheduler`
- [x] ‚úÖ Verificar execu√ß√£o b√°sica do simulador

### üìå 14/11/2025 (Quinta) - **DIA CRUCIAL**
- [ ] ‚ö†Ô∏è **Integrar RoundRobinScheduler ao main.cpp**
  - Modificar loop principal
  - Usar `scheduler.schedule_cycle()`
  - Remover l√≥gica antiga de execu√ß√£o √∫nica

### üìå 15/11/2025 (Sexta)
- [ ] ‚ö†Ô∏è **Criar 5 processos de teste (JSON)**
  - `processo1.json` - CPU-bound (muitas opera√ß√µes ALU)
  - `processo2.json` - I/O-bound (muitos acessos mem√≥ria)
  - `processo3.json` - Misto
  - `processo4.json` - Curto (poucos ciclos)
  - `processo5.json` - Longo (muitos ciclos)

### üìå 16-17/11/2025 (Fim de Semana)
- [ ] Rodar testes com m√∫ltiplos processos
- [ ] Implementar logging de m√©tricas em arquivo
- [ ] Validar que Round Robin est√° funcionando

### üìå 18/11/2025 (Segunda)
- [ ] Executar baseline (1 n√∫cleo)
- [ ] Executar multicore (2, 4 n√∫cleos)
- [ ] Coletar dados para o artigo

---

## ‚ö†Ô∏è Itens de Alta Prioridade

### üî¥ CR√çTICO (Sem isso, trabalho n√£o funciona)

1. **Integrar RoundRobinScheduler ao main.cpp** ‚è∞ **14/11**
   - Atualmente o escalonador existe mas n√£o √© usado
   - `main.cpp` ainda executa um √∫nico processo
   - **A√ß√£o:** Substituir loop por `scheduler.schedule_cycle()`

2. **Criar processos de teste (JSON)** ‚è∞ **15/11**
   - Apenas `tasks.json` existe
   - Precisa de m√∫ltiplos processos para testar RR
   - **A√ß√£o:** Criar `src/tasks/processo{1-5}.json`

3. **Implementar coleta de m√©tricas** ‚è∞ **20/11**
   - M√©tricas calculadas mas n√£o salvas
   - Artigo precisa de dados
   - **A√ß√£o:** Criar `logs/metrics.csv` com resultados

### üü° IMPORTANTE (Impacta qualidade)

4. **Preemp√ß√£o real por quantum** ‚è∞ **17/11**
   - Atualmente processo s√≥ para quando termina
   - Quantum n√£o interrompe execu√ß√£o
   - **A√ß√£o:** Adicionar verifica√ß√£o de quantum no pipeline

5. **Testes de carga multicore** ‚è∞ **19/11**
   - Testar com 2, 4, 8 n√∫cleos
   - Verificar escalabilidade
   - **A√ß√£o:** Criar `test_scalability.cpp`

6. **Gr√°ficos para o artigo** ‚è∞ **26/11**
   - Speedup, utiliza√ß√£o, tempo de espera
   - **A√ß√£o:** Script Python com matplotlib

### üü¢ DESEJ√ÅVEL (Melhora apresenta√ß√£o)

7. **Documenta√ß√£o de API**
8. **Testes de race conditions**
9. **README atualizado com instru√ß√µes de execu√ß√£o**

---

## üìà Indicadores de Progresso

### Por Categoria:

#### üèóÔ∏è Arquitetura Multicore (75% - Quase Pronto)
```
[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë] 6/8 completos
```
- ‚úÖ Classe Core
- ‚úÖ Cache L1 privada
- ‚úÖ Threads ass√≠ncronas
- ‚úÖ Pipeline MIPS por n√∫cleo
- ‚úÖ MemoryManager compartilhado
- ‚úÖ Compila√ß√£o funcionando
- ‚è≥ Teste com 4+ n√∫cleos
- ‚è≥ Documenta√ß√£o de API

#### ‚öôÔ∏è Escalonamento Round Robin (70% - Em Andamento)
```
[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 7/10 completos
```
- ‚úÖ Classe RoundRobinScheduler
- ‚úÖ Fila global FIFO
- ‚úÖ Fila de bloqueados
- ‚úÖ PCB estendido
- ‚úÖ Detec√ß√£o de migra√ß√£o
- ‚úÖ Quantum configur√°vel
- ‚úÖ Estrutura de estat√≠sticas
- ‚è≥ Integra√ß√£o com main.cpp ‚ö†Ô∏è
- ‚è≥ Preemp√ß√£o real
- ‚è≥ M√©tricas calculadas

#### üíæ Gerenciamento de Mem√≥ria (80% - Funcional)
```
[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë] 4/5 completos
```
- ‚úÖ MemoryManager compartilhado
- ‚úÖ Cache L1 privada
- ‚úÖ Contadores de hits/misses
- ‚úÖ Sincroniza√ß√£o
- ‚è≥ Teste de conten√ß√£o

#### üîí Sincroniza√ß√£o (65% - Parcial)
```
[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 3/5 completos
```
- ‚úÖ Mutexes no scheduler
- ‚úÖ Threads sincronizadas
- ‚úÖ Atomic operations
- ‚è≥ Teste de race conditions
- ‚è≥ Documenta√ß√£o

#### üìä M√©tricas e Testes (30% - Atrasado ‚ö†Ô∏è)
```
[‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 2/7 completos
```
- ‚úÖ Estrutura de m√©tricas
- ‚úÖ M√©todos de c√°lculo
- ‚è≥ Processos de teste JSON ‚ö†Ô∏è
- ‚è≥ Logging em arquivo ‚ö†Ô∏è
- ‚è≥ Baseline single-core
- ‚è≥ Speedup
- ‚è≥ Gr√°ficos

#### üìÑ Artigo IEEE (0% - N√£o iniciado ‚ö†Ô∏è‚ö†Ô∏è)
```
[‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 0/6 completos
```
- ‚è≥ Template LaTeX
- ‚è≥ Abstract
- ‚è≥ Introdu√ß√£o
- ‚è≥ Metodologia
- ‚è≥ Resultados
- ‚è≥ Conclus√£o

---

## üéì Crit√©rios de Avalia√ß√£o (30 pontos)

> **Fonte:** Especifica√ß√£o oficial - Michel Pires (CEFET-MG, 2025)  
> **Escopo do grupo:** Round Robin + Infraestrutura multicore

### 1Ô∏è‚É£ Implementa√ß√£o - Escalonamento Round Robin (10 pontos)

- [x] ‚úÖ **Arquitetura multicore funcional** (2 pts)
  - M√∫ltiplos n√∫cleos operando
  - Mem√≥ria compartilhada
  - Cache L1 privada por n√∫cleo

- [x] ‚úÖ **Fila global Round Robin (FIFO)** (1 pt)
  - Implementada em `RoundRobinScheduler`

- [ ] ‚ö†Ô∏è **Cen√°rio 1: Round Robin N√£o-Preemptivo** (2 pts)
  - Especifica√ß√£o: "Cen√°rio n√£o preemptivo: todas as tarefas s√£o executadas at√© a conclus√£o, sem interrup√ß√µes"
  - Processos executam at√© terminar (sem quantum)
  - **FALTANDO - Prioridade Alta**

- [ ] ‚è≥ **Cen√°rio 2: Round Robin Preemptivo** (2 pts)
  - Especifica√ß√£o: "Cen√°rio preemptivo: todas as tarefas s√£o pass√≠veis de interrup√ß√£o, sendo executadas conforme um quantum"
  - Quantum configur√°vel
  - Context switch funcional

- [ ] ‚ö†Ô∏è **Baseline single-core** (2 pts)
  - Especifica√ß√£o: "deve-se utilizar como baseline a arquitetura single-core previamente desenvolvida"
  - Executar com 1 n√∫cleo
  - Comparar com 2, 4 n√∫cleos
  - **FALTANDO - Obrigat√≥rio**

- [ ] ‚è≥ **Arquivos de log de m√©tricas** (1 pt)
  - Especifica√ß√£o: "todas as execu√ß√µes devem gerar arquivos de log contendo m√©tricas de desempenho"
  - Tempo m√©dio de espera/retorno
  - Utiliza√ß√£o da CPU
  - Throughput

**Pontua√ß√£o Estimada Atual: 3/10** ÔøΩ

---

### 2Ô∏è‚É£ Implementa√ß√£o - Gerenciamento de Mem√≥ria (10 pontos)

> **‚ö†Ô∏è NOTA:** Especifica√ß√£o exige pol√≠ticas de substitui√ß√£o. 
> Se seu grupo N√ÉO implementar√° FIFO/LRU, estes pontos ser√£o perdidos ou 
> devem ser implementados por outro membro da equipe.

- [x] ‚úÖ **Infraestrutura b√°sica** (4 pts)
  - Mem√≥ria compartilhada entre n√∫cleos
  - Cache L1 privada por n√∫cleo
  - Sincroniza√ß√£o (mutexes)
  - Contabiliza√ß√£o de hits/misses

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Segmenta√ß√£o de mem√≥ria (modelo Tanenbaum)** (2 pts)
  - Especifica√ß√£o: "mapeamento de endere√ßos segundo um modelo inspirado em Tanenbaum"
  - Endere√ßamento: parte bits = bloco, parte = offset
  - **FALTANDO - Se n√£o for feito, perde 2 pts**

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Pol√≠tica FIFO** (2 pts)
  - Especifica√ß√£o: "O gerenciamento de mem√≥ria deve prever pol√≠ticas de substitui√ß√£o (ex.: FIFO, LRU)"
  - **FALTANDO - Se n√£o for feito, perde 2 pts**

- [ ] ‚ö†Ô∏è‚ö†Ô∏è **Pol√≠tica LRU** (2 pts)
  - Especifica√ß√£o: exige pol√≠ticas de substitui√ß√£o
  - **FALTANDO - Se n√£o for feito, perde 2 pts**

**Pontua√ß√£o Estimada Atual: 4/10** üî¥  
**Pontua√ß√£o Poss√≠vel (sem FIFO/LRU): 6/10** ÔøΩ

---

### 3Ô∏è‚É£ Artigo Cient√≠fico IEEE (10 pontos)

> **Especifica√ß√£o:** "Artigo cient√≠fico descrevendo o trabalho desenvolvido, no formato IEEE Conference Template"

- [ ] ‚è≥ **Estrutura IEEE correta** (1 pt)
  - Template LaTeX ou Word IEEE
  - Formata√ß√£o adequada

- [ ] ‚è≥ **Resumo/Abstract** (1 pt)
  - 150-200 palavras
  - Problema, solu√ß√£o, resultados

- [ ] ‚è≥ **Introdu√ß√£o** (1 pt)
  - Contexto e motiva√ß√£o
  - Objetivos do trabalho

- [ ] ‚è≥ **Referencial Te√≥rico** (2 pts)
  - Arquiteturas multicore
  - Escalonamento Round Robin
  - Gerenciamento de mem√≥ria
  - M√≠nimo 10 refer√™ncias

- [ ] ‚è≥ **Metodologia e Implementa√ß√£o** (2 pts)
  - Pseudoc√≥digos
  - Diagramas da arquitetura
  - Fluxogramas

- [ ] ‚è≥ **Resultados e Discuss√£o** (2 pts)
  - Gr√°ficos comparativos
  - Tabelas de m√©tricas
  - Compara√ß√£o baseline vs multicore
  - An√°lise de desempenho

- [ ] ‚è≥ **Conclus√£o e Trabalhos Futuros** (1 pt)
  - S√≠ntese das contribui√ß√µes
  - Limita√ß√µes e melhorias futuras

**Pontua√ß√£o Estimada Atual: 0/10** ‚≠ï

---

### **TOTAL AJUSTADO:**

| Componente | Atual | Com FIFO/LRU | M√°ximo |
|------------|-------|--------------|--------|
| Escalonamento | **3/10** üî¥ | **10/10** ‚úÖ | 10 |
| Mem√≥ria | **4/10** üî¥ | **10/10** ‚úÖ | 10 |
| Artigo | **0/10** ‚≠ï | **10/10** ‚úÖ | 10 |
| **TOTAL** | **7/30** (23%) | **30/30** (100%) ‚úÖ | **30** |

> ‚ö†Ô∏è **CR√çTICO:** FIFO/LRU vale 6 pontos! Ver **ETAPA 3.5** para guia completo.
> 
> **Divis√£o Grupo:**
> 1. ‚úÖ **Voc√™:** Round Robin (10 pts) - 70% completo
> 2. üî¥ **Outro membro:** FIFO/LRU (6 pts) - **VER ETAPA 3.5**
> 3. üë• **Todos:** Artigo IEEE (10 pts) - iniciar 27/11
> 
> **ETAPA 3.5** cont√©m:
> - üìù C√≥digo completo de FIFOPolicy e LRUPolicy
> - üß™ Testes unit√°rios prontos
> - üìÖ Divis√£o de tarefas por dia (19-23/11)
> - üîó Integra√ß√£o com Cache existente

---

## üö® Riscos e Mitiga√ß√£o

| Risco | Probabilidade | Impacto | Mitiga√ß√£o |
|-------|---------------|---------|-----------|
| **N√£o implementar cen√°rio n√£o-preemptivo** | ÔøΩ Alta | üî¥ Alto (-2 pts) | Prioridade m√°xima - fazer at√© 17/11 |
| **N√£o testar baseline single-core** | üî¥ Alta | üî¥ Alto (-2 pts) | Reservar 24-26/11 para testes |
| **N√£o gerar arquivos de log** | üü° M√©dia | üî¥ Alto (-1 pt) | Implementar at√© 20/11 |
| **N√£o implementar FIFO/LRU** | üü° M√©dia | üî¥ CR√çTICO (-6 pts) | **VER ETAPA 3.5** - Outro membro deve implementar |
| **Artigo incompleto/atrasado** | ÔøΩ M√©dia | ÔøΩ Alto (-10 pts) | Come√ßar em 27/11, dividir se√ß√µes |
| **Cen√°rio preemptivo mal implementado** | ÔøΩ Baixa | üü° M√©dio (-2 pts) | Testar quantum funciona corretamente |

---

## üìö Recursos Dispon√≠veis

### Documenta√ß√£o Interna:
- ‚úÖ `docs/08-round-robin.md` - Guia completo de Round Robin (684 linhas)
- ‚úÖ `docs/COMPILACAO_SUCESSO.md` - Resumo de implementa√ß√£o
- ‚úÖ `docs/WSL_QUICKSTART.md` - Guia de compila√ß√£o
- ‚úÖ `docs/02-requisitos.md` - Requisitos detalhados
- ‚úÖ `docs/04-roadmap.md` - Roadmap original

### C√≥digo Implementado:
- ‚úÖ `src/cpu/Core.hpp/cpp` - N√∫cleo de processamento
- ‚úÖ `src/cpu/RoundRobinScheduler.hpp/cpp` - Escalonador
- ‚úÖ `src/cpu/PCB.hpp` - PCB estendido
- ‚úÖ `src/memory/MemoryManager.hpp/cpp` - Gerenciador de mem√≥ria
- ‚úÖ `Makefile` - Build configurado

### Ferramentas:
- ‚úÖ GCC 13 (C++17)
- ‚úÖ WSL Ubuntu
- ‚úÖ Make
- ‚è≥ Python + matplotlib (para gr√°ficos)
- ‚è≥ LaTeX (para artigo)

---

## üéØ A√ß√µes Imediatas (Pr√≥ximas 48h)

### Amanh√£ - 14/11/2025:
1. ‚ö†Ô∏è **Modificar `src/main.cpp`**
   - Instanciar `RoundRobinScheduler`
   - Loop: `while (scheduler.has_pending_processes()) { scheduler.schedule_cycle(); }`
   - Remover execu√ß√£o direta do processo

2. ‚ö†Ô∏è **Testar execu√ß√£o b√°sica**
   - Compilar: `make simulador`
   - Executar: `./simulador`
   - Verificar que escalonador est√° funcionando

### 15/11/2025:
3. ‚ö†Ô∏è **Criar processos de teste**
   - Copiar `src/tasks/tasks.json` como template
   - Criar varia√ß√µes de carga
   - Documentar em `docs/EXEMPLOS_JSON.md`

4. ‚ö†Ô∏è **Modificar main.cpp para carregar m√∫ltiplos processos**
   - Loop para carregar `processo1.json`, `processo2.json`, etc.
   - `scheduler.add_process(pcb)` para cada um

---

## üìû Divis√£o de Tarefas (Sugerida)

### Pessoa 1 - Escalonador:
- [ ] Integrar RoundRobinScheduler ao main.cpp
- [ ] Implementar preemp√ß√£o por quantum
- [ ] Testar com m√∫ltiplos processos

### Pessoa 2 - Testes:
- [ ] Criar 5 processos JSON
- [ ] Executar baseline (1 n√∫cleo)
- [ ] Executar multicore (2, 4 n√∫cleos)
- [ ] Coletar dados

### Pessoa 3 - M√©tricas:
- [ ] Implementar logging em arquivo
- [ ] Calcular speedup
- [ ] Criar gr√°ficos (Python)

### Pessoa 4 - Artigo:
- [ ] Baixar template IEEE
- [ ] Escrever Abstract + Introdu√ß√£o
- [ ] Escrever Metodologia
- [ ] Compilar resultados + conclus√£o

---

## ‚úÖ Como Marcar um Achievement

Quando completar uma tarefa:

1. **Mudar `[ ]` para `[x]`**
2. **Adicionar data de conclus√£o: `‚úÖ (DD/MM/2025)`**
3. **Atualizar percentuais no topo**
4. **Commitar a mudan√ßa:**
   ```bash
   git add docs/ACHIEVEMENTS.md
   git commit -m "Achievement: [nome da tarefa]"
   ```

---

## üèÅ Defini√ß√£o de "Pronto"

Uma etapa est√° completa quando:

- ‚úÖ C√≥digo compila sem erros
- ‚úÖ Testes b√°sicos passam
- ‚úÖ Documenta√ß√£o atualizada
- ‚úÖ Commit feito no reposit√≥rio
- ‚úÖ Revisado por outro membro da equipe

---

## üìã **CHECKLIST FINAL - Requisitos do Professor**

> **Use esta lista para garantir que NADA foi esquecido!**

### ‚úÖ **Implementa√ß√£o - Escalonamento Round Robin (10 pts):**

- [x] ‚úÖ Arquitetura multicore funcional (2 pts)
- [x] ‚úÖ Fila FIFO de processos (1 pt)
- [ ] ‚ö†Ô∏è **Cen√°rio n√£o-preemptivo** (2 pts) - **FALTA**
- [ ] ‚è≥ **Cen√°rio preemptivo com quantum** (2 pts) - **EM ANDAMENTO**
- [ ] ‚ö†Ô∏è **Baseline single-core comparativo** (2 pts) - **FALTA**
- [ ] ‚è≥ **Arquivos de log gerados** (1 pt) - **FALTA**

**Status:** 3/10 pts (30%) - **7 pontos em risco!**

---

### ‚úÖ **Implementa√ß√£o - Gerenciamento de Mem√≥ria (10 pts):**

#### Sua Parte (Infraestrutura - 4 pts):
- [x] ‚úÖ Mem√≥ria compartilhada entre n√∫cleos
- [x] ‚úÖ Cache L1 privada por n√∫cleo
- [x] ‚úÖ Sincroniza√ß√£o thread-safe
- [x] ‚úÖ Contabiliza√ß√£o hits/misses

#### Outro Membro (Pol√≠ticas - 6 pts):
- [ ] ‚è≥ Segmenta√ß√£o modelo Tanenbaum (2 pts)
- [ ] ‚è≥ Pol√≠tica FIFO (2 pts)
- [ ] ‚è≥ Pol√≠tica LRU (2 pts)

**Status:** 4/10 pts (40%) - **6 pontos em risco se ningu√©m fizer!**

---

### ‚úÖ **Artigo Cient√≠fico IEEE (10 pts):**

- [ ] ‚è≥ Template IEEE baixado e configurado
- [ ] ‚è≥ Resumo/Abstract escrito
- [ ] ‚è≥ Introdu√ß√£o escrita
- [ ] ‚è≥ Referencial Te√≥rico (m√≠n. 10 refs)
- [ ] ‚è≥ Metodologia e Implementa√ß√£o
- [ ] ‚è≥ Resultados com gr√°ficos comparativos
- [ ] ‚è≥ Conclus√£o e Trabalhos Futuros

**Status:** 0/10 pts (0%) - **10 pontos em risco!**

---

### ‚úÖ **Requisitos T√©cnicos Espec√≠ficos:**

#### Carga de Processos:
- [ ] ‚ö†Ô∏è **Todos processos carregados ANTES da execu√ß√£o**
- [ ] ‚ö†Ô∏è **Sem novos processos durante execu√ß√£o**
- [ ] ‚ö†Ô∏è **M√≠nimo 5 processos JSON diferentes**

#### Cen√°rios Experimentais:
- [ ] ‚ö†Ô∏è **Cen√°rio 1: N√£o-preemptivo implementado**
- [ ] ‚è≥ **Cen√°rio 2: Preemptivo implementado**
- [ ] ‚è≥ Context switch funcional entre cen√°rios

#### Baseline e Compara√ß√£o:
- [ ] ‚ö†Ô∏è **Executar com 1 n√∫cleo (baseline)**
- [ ] ‚è≥ Executar com 2 n√∫cleos
- [ ] ‚è≥ Executar com 4 n√∫cleos
- [ ] ‚è≥ Calcular speedup
- [ ] ‚è≥ Gerar gr√°ficos comparativos

#### M√©tricas Obrigat√≥rias:
- [ ] ‚è≥ Tempo m√©dio de espera
- [ ] ‚è≥ Tempo m√©dio de retorno
- [ ] ‚è≥ Utiliza√ß√£o m√©dia da CPU
- [ ] ‚è≥ Efici√™ncia por n√∫cleo
- [ ] ‚è≥ Throughput total

#### Logs e Documenta√ß√£o:
- [ ] ‚ö†Ô∏è **Arquivos de log gerados automaticamente**
- [ ] ‚è≥ Logs com formato estruturado (CSV/JSON)
- [ ] ‚è≥ C√≥digo comentado e publicado no GitHub
- [ ] ‚è≥ README com instru√ß√µes de compila√ß√£o

---

## üéØ **RESUMO DE RISCO POR PONTOS:**

| Item | Pontos | Status | Prazo | Risco |
|------|--------|--------|-------|-------|
| Cen√°rio n√£o-preemptivo | 2 | ‚ö†Ô∏è FALTA | 17/11 | üî¥ ALTO |
| Baseline single-core | 2 | ‚ö†Ô∏è FALTA | 24/11 | üî¥ ALTO |
| Cen√°rio preemptivo | 2 | ‚è≥ 70% | 19/11 | üü° M√âDIO |
| Logs de m√©tricas | 1 | ‚è≥ 0% | 20/11 | üü° M√âDIO |
| Arquitetura multicore | 2 | ‚úÖ FEITO | - | üü¢ SEGURO |
| Fila FIFO processos | 1 | ‚úÖ FEITO | - | üü¢ SEGURO |
| **TOTAL ESCALONAMENTO** | **10** | **30%** | - | **üî¥ 7 pts em risco** |
| | | | | |
| Infraestrutura mem√≥ria | 4 | ‚úÖ FEITO | - | üü¢ SEGURO |
| FIFO/LRU (outro membro) | 6 | ‚è≥ 0% | 23/11 | üî¥ ALTO |
| **TOTAL MEM√ìRIA** | **10** | **40%** | - | **üî¥ 6 pts em risco** |
| | | | | |
| Artigo IEEE | 10 | ‚è≥ 0% | 06/12 | üî¥ ALTO |
| **TOTAL ARTIGO** | **10** | **0%** | - | **üî¥ 10 pts em risco** |
| | | | | |
| **TOTAL GERAL** | **30** | **23%** | - | **üî¥üî¥üî¥ 23 pts em risco!** |

---

**√öltima atualiza√ß√£o:** 13/11/2025 23:59  
**Pr√≥xima revis√£o:** 16/11/2025

---

> üí° **Dica:** Mantenha este arquivo aberto durante o desenvolvimento para visualizar progresso em tempo real!
